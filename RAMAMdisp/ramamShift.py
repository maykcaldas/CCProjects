!/usr/bin/python3
#!-*- coding: utf8 -*-

''' Documentation '''

import sys
import time
import os
import universe
import shutil
import argparse

def print_header():
    print('\n')
    print('##########################################################')
    print('#    Automated generator to RAMAM maximum displacement   #')
    print('# Usage:                                                 #')
    print('# python3 ramamShift.py <input file> <nsteps>            #')
    print('#                                                        #')
    print('# We are currently only supporting the TurboMole output. #')
    print('##########################################################')
    print('\n')

    return None


def read_input(input_name):
    ''' Documentation '''
    if not os.path.isfile(input_name):
        return False
    return True


def read_eq_coord(file_name):
    ''' Documentation '''
    file = open(file_name, 'r' )
    inp=file.readlines()
    file.close()

    for lineN in range(len(inp)):

        molecule=[]
        if "atomic coordinates" in inp[lineN]:
            # end=False
            count=1
            while (inp[lineN+count][:-1] != " "):
                line=inp[lineN+count][:-1].split()

                atom=universe.atom(name = line[3],
                                    x = line[0],
                                    y = line[1],
                                    z = line[2])

                molecule.append(atom)
                count+=1
            break
    return molecule

def read_displacements(file_name,molecule):
    ''' Documentation '''
    file = open(file_name, 'r' )
    inp=file.readlines()
    file.close()

    for lineN in range(len(inp)):
        if "NORMAL MODES and VIBRATIONAL FREQUENCIES" in inp[lineN]:
            # end=False
            count=12 #skipping the frequencies documentation
            while (not "time elapsed for vibrational analysis" in inp[lineN+count][:-1]):
                if "RAMAN" in inp[lineN+count][:-1]:
                    count+=2 #Jumping the empty line before the RAMAN statment
                    for atom in molecule:
                        line = inp[lineN+count][:-1].split()
                        for disp in range(3,len(line)):
                            atom.set_Dx(line[disp])
                        count+=1
                        
                        line = inp[lineN+count][:-1].split()
                        for disp in range(1,len(line)):
                            atom.set_Dy(line[disp])
                        count+=1
                        
                        line = inp[lineN+count][:-1].split()
                        for disp in range(1,len(line)):
                            atom.set_Dz(line[disp])
                        count+=1
                    # break
                count+=1
                line=inp[lineN+count][:-1].split()
    return None

def create_dir(path):
    ''' Documentation '''
    try:
        os.mkdir(path)
    except FileExistsError:
        shutil.rmtree(path)
        os.mkdir(path)
    return None

def write_coord(input_name, molecule, nsteps):
    ''' Documentation '''
    input_name = input_name+"_steps"
    dispCount=0
    create_dir("{0}".format(input_name))
    for disp in range(len(molecule[0].get_Dx())):
        dispName="{0:0>3}_mode".format(dispCount+1)
        create_dir("{0}/{1}".format(input_name, dispName))
        for step in range(-nsteps,nsteps+1):
            stepName="{0:0>2}_step".format(step)
            create_dir("{0}/{1}/{2}".format(input_name, dispName, stepName))
            out = open("{0}/{1}/{2}/coord".format(input_name, dispName, stepName),'w')
            out.write("\n")
            out.write("File automated generated by a cool script. :)\n")
            out.write("Python rules\n")
            out.write("That's an easter egg :v Comment lines from 113 until 120\n")
            out.write("\n")
            out.write("{0}\n".format(len(molecule)))
            out.write("Step number {0:0>2} of the frequencie mode number {1:0>3} discretization\n".format(step, dispCount+1))
            out.write("$coord\n")
            for atom in molecule:
                xCoord=float(atom.get_x()) + float(atom.get_Dx()[dispCount])*(step/nsteps)
                yCoord=float(atom.get_y()) + float(atom.get_Dy()[dispCount])*(step/nsteps)
                zCoord=float(atom.get_z()) + float(atom.get_Dz()[dispCount])*(step/nsteps)
                out.write("{1: 12.5f} {2: 12.5f} {3: 12.5f} {0:>5s}\n".format(atom.get_name(),
                                                    float(xCoord),
                                                    float(yCoord),
                                                    float(zCoord)))
            out.write("$end\n")
            out.close()
        dispCount+=1

    return None

def main():
    ''' Documentation '''

    startTime=time.time()

    run_dir = os.path.dirname(__file__)
    print_header()

    if len(sys.argv) == 2:
        print("The nsteps parameter was not passed.")
        print("Assuming the default nsteps=5.\n")
        nsteps=5
    else:
        nsteps=sys.argv[2]
        try:
            nsteps=int(nsteps)  
        except ValueError:
            print("nsteps should be an integer.\n")
            exit()

    if len(sys.argv) < 2:
        print("Insuficient parameters.")
        print("Check the usage of the software at the header.\n")
        exit()

    input_file=sys.argv[1]
    if not read_input(input_file):
        print("Check your input file name!!\n")
        exit()


    #######################
    #### Program start ####
    #######################

    molecule = read_eq_coord(input_file)


    print("{0} atoms computed.".format(len(molecule)))
    print("{0} frequencies evaluated.".format(len(molecule[0].get_Dx())))

    read_displacements(input_file,molecule)
    write_coord(input_file[:-4], molecule,nsteps)

    print("The output coordinate files are at {0} folder\n".format(input_file[:-4]+"_steps"))

    print("The run took: {0} seconds".format(time.time()-startTime))

if __name__ == "__main__":
    main()
